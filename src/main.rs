use crate::change::change_prj;
use clap::{Parser, Subcommand};
use core::panic;
use init::init_prj;
use inquire::{Confirm, MultiSelect, Text};
use migrate::migrate_to_new_config;
use new::new_prj;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::PathBuf;
use std::{fs, vec};
use tree::get_project_tree;
use utils::{path_from_iter, search_for_project, HOME_FOLDERS};

mod change;
mod init;
mod migrate;
mod new;
mod tree;
mod utils;

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
pub struct Args {
    #[clap(subcommand)]
    command: Option<Command>,

    project_name: Option<String>,
}

#[derive(Debug, Subcommand)]
pub enum Command {
    #[clap(about = "[Default] Change the active project.")]
    Change {
        /// project to change to
        project_name: String,
    },
    #[clap(about = "Turn the working directory into a new project.")]
    New {
        /// Name of the new project
        project_name: String,

        /// parent project
        #[clap(short, long)]
        parent: Option<String>,
        /// folders to create in the new project
        #[clap(long, value_parser, num_args = 1.., value_delimiter = ' ')]
        folders: Option<Vec<String>>,
    },
    #[clap(
        about = "Initialize the config file and create a default project and move the folders to it."
    )]
    Init,

    #[clap(about = "Returns the project tree structure as a json string")]
    Tree,
    #[clap(about = "Returns the path to the project folder")]
    Path { project_name: String },
}

#[derive(Default, Deserialize, Serialize, Debug)]
struct OldConfig {
    active: String,
    all_prjs: OldProject,
}

#[derive(Default, Deserialize, Serialize, Debug)]
struct OldProject {
    name: String,
    path: String,
    folder: Vec<String>,
    children: Vec<OldProject>,
}

#[derive(Default, Deserialize, Serialize, Debug)]
struct Config {
    active: String,
    base_folder: PathBuf,
}

const CONFIG_NAME: &str = "wechsel_projects.json";
const FOLDER_PREFIX: &str = "_";
const PROJECTS_FOLDER: &str = "projects";

fn main() {
    let args = Args::parse();

    let config_dir: PathBuf = PathBuf::from_iter([
        dirs::config_dir().expect("No config folder found"),
        PathBuf::from("wechsel"),
    ]);
    if !config_dir.exists() {
        fs::create_dir(&config_dir).expect("Could not create config folder");
    }

    let config_path: PathBuf = path_from_iter([config_dir.clone(), PathBuf::from(CONFIG_NAME)]);

    // Check if Init is selected
    let (mut config, mut prj_name) = if let Some(Command::Init) = args.command {
        let conf = init_prj(config_dir.clone()).expect("Could not create initial project");

        if config_path.exists() {
            println!("Config file already exists, keeping the old one");
            (None, None)
        } else {
            let name = conf
                .base_folder
                .file_name()
                .and_then(|name| name.to_str())
                .map(|name| name.to_string())
                .expect("Could not parse name of root project");
            (Some(conf), Some(name))
        }
    } else {
        (None, None)
    };

    if prj_name.is_none() && args.project_name.is_some() {
        prj_name = args.project_name;
    }
    // Load config if Init was not the command
    if config.is_none() {
        // Load Config
        if !config_path.exists() {
            panic!("No config file, you might want to call this script with \"inital\"")
        }
        let contents =
            fs::read_to_string(&config_path).expect("Should have been able to read the file");

        if let Ok(conf) = serde_json::from_str(&contents) {
            config = Some(conf);
        } else if let Ok(conf) = serde_json::from_str::<OldConfig>(&contents) {
            match Confirm::new("Your wechsel conf was generated by an old wechsel version. Do you want wechsel to migrate your config file and projects folders to the new style? This will rename some folders and symlink some projects into new places.")
                .prompt() {
                    Ok(true) => (),
                    _ => std::process::exit(1)
                };

            config = Some(migrate_to_new_config(conf));
        }
    }

    let mut config = config.unwrap();

    if let Some(cmd) = &args.command {
        match cmd {
            Command::New {
                project_name,
                parent,
                folders,
            } => {
                prj_name = Some(project_name.clone());

                let pwd = std::env::current_dir().expect("Could not get current dir");
                let mut parent_folder = pwd.clone();
                parent_folder.pop();

                let found_parent = parent
                    .is_none()
                    .then(|| {
                        parent_folder
                            .file_name()
                            .and_then(|name| name.to_str())
                            .map(|mame| mame == PROJECTS_FOLDER)
                            .unwrap_or_default()
                            .then(|| {
                                //Parent is a Projects Folder to this directory is a project
                                pwd.file_name()
                                    .and_then(|name| name.to_str())
                                    .expect("Could not get parent folder name")
                                    .to_string()
                            })
                    })
                    .flatten();

                let (parent, folders) = if parent.is_none() && folders.is_none() {
                    // If no options are set, ask for them interactivly

                    let pwd = std::env::current_dir().expect("Could not get current dir");
                    let mut parent_folder = pwd.clone();
                    parent_folder.pop();

                    let parent = found_parent.unwrap_or_else(|| {
                        // not in a wechsel project so the user has to supply a parent
                        let Ok(parent) = Text::new("parent project")
                            .with_default(&config.active)
                            .prompt()
                        else {
                            std::process::exit(1);
                        };
                        parent
                    });

                    let Ok(folders) = MultiSelect::new(
                        "Select folders to move to the new project",
                        HOME_FOLDERS.to_vec(),
                    )
                    .with_default(&[0, 1, 2, 3, 4, 5])
                    .prompt() else {
                        std::process::exit(1);
                    };

                    let folders: Vec<String> = folders
                        .into_iter()
                        .map(|folder| folder.to_owned())
                        .collect();

                    (parent, folders)
                } else {
                    (
                        parent.clone().unwrap_or(config.active.clone()),
                        folders
                            .clone()
                            .unwrap_or(vec!["Desktop".to_owned(), "Downloads".to_owned()]),
                    )
                };

                new_prj(&mut config, project_name, folders, parent, &config_dir)
                    .expect("Could not create new project");
            }
            Command::Change { project_name } => prj_name = Some(project_name.clone()),
            Command::Init => (),
            Command::Tree => {
                println!(
                    "{}",
                    serde_json::to_string_pretty(&get_project_tree(config.base_folder.clone()))
                        .unwrap_or_default()
                )
            }
            Command::Path { project_name } => {
                if let Some(path) = search_for_project(config.base_folder.clone(), project_name)
                    .map(|mut path| path.remove(0))
                    .and_then(|path| path.to_str().map(|path| path.to_string()))
                {
                    println!("{path}");
                }
            }
        }
    }

    let after_scripts = if let Some(prj_name) = prj_name {
        //Change Project
        match change_prj(&prj_name, &mut config, config_dir) {
            Ok(after_scripts) => {
                println!("Changed to Project {}", prj_name);
                Some(after_scripts)
            }
            Err(e) => {
                println!("Could not change to Project {}, Error: {}", prj_name, e);
                None
            }
        }
    } else {
        // Don't change the active project
        None
    };

    //Write Config to json
    std::fs::write(&config_path, serde_json::to_string_pretty(&config).unwrap())
        .expect("Could not write to config file");

    // Execute the Scripts after changing the project
    if let Some((after_scripts, env_vars)) = after_scripts {
        fn execute(script: PathBuf, env_vars: &HashMap<String, String>) {
            if script.is_file() {
                if let Ok(mut child) = std::process::Command::new("sh")
                    .envs(env_vars)
                    .arg("-c")
                    .arg(&script)
                    .spawn()
                {
                    let _ = child.wait();
                }
            }
        }

        for script in after_scripts {
            execute(script, &env_vars);
        }
    }
}
